# 論文のテーマ
近年大規模データ処理ではMapReduceフレームワークがデファクトスタンダードになっている。
このフレームワークはGoogleによって開発されたもので、OSS版のHadoopは多くの企業や大学で利用されている。(弊社でもめちゃめちゃ使ってます。)

MapReduceフレームワークは既存のよく研究されている並列コンピューティングとは以下の点で異なる。
- 並列計算と逐次計算を織り交ぜている

この新しいフレームワークについて、すでに様々なアルゴリズムが提案されているが、既存の有名な並列計算のモデルであるPRAMのような、しっかりとしたモデルはまだ提案されていなかった。
この研究では、MapReduceの正式なモデルを定義しPRAMモデルと比較する。

主な結果
- $O(n^{2-\epsilon})$のプロセッサーと$O(n^{2-\epsilon})$のトータルメモリを使用するPRAMアルゴリズムのサブラクラスはMapReduceで模倣することができる
- MapReduceで利用できる2つの並列化のためのテクニックを示し、それを応用してdence grapfにおけるMSTとundirected s-t connectivityを解くアルゴリズムを示す

# MapReduce Basics
MapReduceプログラミングにおける基本的な情報の単位はキーバリューペア
- $<key; value>$
  - $key$と$value$はバイナリ文字列

任意のMapReduceアルゴリズムの入力はキーバリューペアのセットである。
このセットは以下の3つのステージで操作される。  
1. map stage
2. shuffle stage
3. reduce stage

(関数型のプログラミングをしたことがあると分かりやすいかも)  

map stageではmapper $\mu$が1つのキーバリューペアーを入力として受け取り、任意の数のキーバリューペアーを出力する。map操作の特徴はstatelessであること。この特性のため、別々のマシンで並列にmap操作を行うことができる。

shuffle stageでは、MapReduceを実装しているシステムが同じキーを持つペアは同じマシンに配置されるように、map stageの出力を分配する。このステージはシームレスに行われ、プログラマーは意識する必要がない。

reduce stageでは、reducer $\rho$がキー $k$を持つ全てのペアを入力に取り$k$をキーに持つペアのマルチセットを出力する。よって、**reducerが処理を実行する前にすべてのmapperの処理が終わっている必要がある。**

reducer単体の処理は逐次的に行われるが、異なるreducerは同時に並列に実行される。

MapReduceではこのようなmapperとreducerが繰り返し実行される。

## MapReduce Example
MapReduceの簡単な例として$k$-th frequency momentの計算を取り上げる。$k$-th frequency momentの定義

$F_k(a) = \Sigma_{i=1}^n a_i^k$

$a$はフリークエンシーの集合

問題定義
- $x$ : 長さ$n$の入力文字列
- $x_i$ : $x$における$i$番目の文字
- $\$$ : 特殊文字
- MapReduceの入力は$<i; x_i>$で表す

プログラムの流れ
1. 最初のmapper $\mu_1$ではキーとバリューを入れ替える
   - $\mu_1(<i;x_i>) = <x_i; i>$
2. 最初のreducer $\rho_1$では、集められたペアーから部分的なfrequency momentを計算する
   - $\rho_1(<x_i; {v_1, \dots, v_m}>) = <x_i; m^k>$
3. 次のmapperでは2の計算結果を足し合わせるために、キーを特殊文字に置き換える
   - $\mu_2(<x_i; v>) = <\$; v>$
4. 全ペアーが同じキーを持つので、すべての入力は一つのマシンに集められる。よって最後はすべてを足し合わせればいい
   - $\rho_2(<\$; {v1, \dots, v_l}>) = <\$, \Sigma_i v_i>$

並列化の容易さの他のMapReduceの利点はフレームワークがフォールトトレランスやデータの分配といった低レベルの処理をプログラマーに対して隠蔽していること。プログラマーはそういったことを意識せずにmapperとreducerのみを開発すれば良い。

一方で欠点は並列性を得るために、プログラマーはプログラムをmapperとreducerの落とし込まないといけないこと。
つまり柔軟性と並列化の容易さがトレードオフになっている。
どのような種類の問題がMapReduceで効率的に解けるのかは自明ではない。この論文では、MapReduceでどのような問題が効率的に解けるのかを明らかにするためにモデルを定義した。

# The Mapreduce Programming Paradigm
ここからMapReduceの定式化を始めていく。
最初にmapperとreducerを定義するところから始める

Definition 2.1


